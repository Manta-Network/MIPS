# MIP-0002 : MantaPay Protocol

```
Number:  MIP-0002
Title:   MantaPay Protocol
Type:    Standard
Status:  Draft
Authors: Shumo Chu (shumo@manta.network)
Created: 2021-06-18
```

## 1. Abstract

`MIP-0002` describes the MantaPay protocol. This is inteneded to be an "informal" 
treatment of the protocol that optimizes readablilty. The formal treatment of the 
protocol can be found in this [eprint](https://eprint.iacr.org/2021/743).

## 2. Primitives

* **zkSNARK**: public-verifiable preprocessing zero-knowledge Succinct Non-interactive
  ARgument of Knowledge. zkSNARK is a proof system that verifies computation expressed 
  in a circuit. Given a field F, a zkSANRK for F-arithmetic circuit satisfablility is defined 
  by a triple of polynomial algorithms (`KeyGen`, `Prove`, `Verify`):
    1. `KeyGen`(1<sup>&lambda;</sup>, `C`) &rarr; (`pk`, `vk`). Taken a security parameter 
    &lambda; (e.g. 128 bits) and a F-arithmeic circuit `C`, `KeyGen` samples a pair of keys, 
    namely a proving key `pk` and a verification key `vk`. (`pk`, `vk`) is usually referred 
    as the public parameter or common reference string (CRS).
    2. `Prove`(`pk`, `x`, `a`) &rarr; &pi;. Taken a proving key `pk`, public input `x`, and 
    witness `a` as input, the proving function `Prove` (called by the prover) outputs a
    non-interactive zero-knowledge proof of the designated statement defined by `C`.
    3. `Verify`(`vk`, `x`, &pi;) &rarr; {0, 1}. Taken a verification key `vk`, and a 
    zero-knowledge proof &pi;, `Verify` (called by the verifier) outputs 1 if the prover is convinced that `C` is true, outputs 0 otherwise.
  A zkSNARK satisfies the following properties:
    - **Completeness**. An honest prover must convince the verifier with high probability 
      1 - `negl`(&lambda;).
    - **Soundness**. If the verifier accepts a proof from a prover with bounded computational
      power, then the prover must know the secrets input corresponding to the witness of the 
      given instance.
    - **Succinctness**. An honest-generated proof &pi; has constant size and the `Verify`
      runs in time linear to `x`.
    - **Zero-Knowledge**. An honestly-generated proof is perfect zero knowledge 
      (the formal definition is based on the notion of the simulator, please refer to 
      A.1 section of the eprint).
* **Commitment** (`COMM`). A non-interactive commitment scheme `COMM` that is both hiding 
  and binding (either computational or information theoretical). For example, given a random 
  seed `r`and a message `m`, the commitment is `c` := `COMM`<sub>r</sub>(`m`). `c` can be 
  opened by revealing `r` and `m`, which verifies the commitment.
* **Pseudo-Random Function** (`PRF`). More specifically, we use three labeled pseudo-random
  functions that instantiated from the same core function. For a seed `x`, we derive 
  `PRF`<sub>`x`</sub><sup>`addr`</sup>(&middot;), 
  `PRF`<sub>`x`</sub><sup>`vn`</sup>(&middot;), and
  `PRF`<sub>`x`</sub><sup>`pk`</sup>(&middot;), which is used to generate addresses, 
  void numbers, and public keys, accordingly. Currently, manta uses `Blake2s` as the core 
  function.
* **Cryptographic Accumulator** (`acc`). `acc` supports efficient, zero-knowledge, 
  membership proofs. Currently, Manta uses merkle tree with pedersen hashes as the `CRH` 
  (collision resistence hash). In MantaPay, we use a sharded accumulator with `256` shard,
  each shard can be indexed by a number from `0` to `255`, e.g. `acc`<sub>i</sub>, 
  where 0 &le; i &le; 255.
* **Elliptic Curve Integrated Encryption Scheme** (`ECIES`). `ECIES` is build on top of 
  (elliptic curve) Diffie-Hellman key exchange protocol, a key derivation function and a 
  block cipher. `ECIES` is used to encrypt the nomination of the UTXO using the receiver's 
  public key. (TODO (ask zz): add the instantiation of `ECIES` that Manta uses).

## Shielded Address, UTXO and Ledger State

* **Shielded Address**. A shielded address is the address that the receiver need to 
  send to the sender prior a private transaction. A deserialized shielded address contains 
  the following (see `MantaAssetShieldedAddress` in `manta-types/manta-asset`):
    - `asset_id`: an `u32` asset id (There will be PR to change the current code)
    - `k`: public information `k` (will be explained later) 
    - `s`: public information `s` (will be explained later)
    - `r`: public information `r` (will be expalined later)
    - `ecpk`: an ECIES public key of the receiver 
  The shielded address will be serialized into a `XXX` bytes address that can be encoded into 
  `XXX` base64 string. (TODO: specify a concrete protocol of serialization).
* **UTXO**. MantaPay uses UTXOs rather than account for the private coins. Both *Mint* and  
  *PrivateTranfer* generates a new UTXO to the ledger state. 
* **Ledger State**. MantaPay's ledger state contains the following:
    - `acc`: A sharded accumulator with `256` shard, i.e. `acc`<sub>i</sub>,  
      where 0 &le; i &le; 255. See `CoinShards` in `pallet-manta-pay`.
    - `vn_list`: a list of void numbers. A void number is also known as a `serial number` 
      or `nullifier` in other protocols. Each coin has a unique void number, and if this
      number is revealed, the coin is voided. See `VNList` in `pallet-manta-pay`.
    - `env_value_list`: a list of encrypted values (of the UTXOs). See `EncValueList` in 
      `pallet-manta-pay`.
    - `pool_balance`: the total balance of MantaPay's private asset pool. See `PoolBalance`
      in `pallet-manta-pay`.
    - `hash_param_checksum` (immutable): the checksum of the `CRH`'s parameters (used in    
      `acc`). See `HashParamChecksum` in `pallet-manta-pay`.
    - `commit_param_checksum` (immutable): the checksum of the commitment's parameters. See
      `CommitParamChecksum` in `pallet-manta-pay`.
    - `transfer_zkp_key_checksum` (immutable): the checksum of the verification key for 
       zero-knowledge proof for transfer protocol (`transfer_vk`). At the moment we are storing the whole serialized key in the ledger state. See `TransferZKPKeyChecksum` 
       in `pallet-manta-pay`.
    - `reclaim_zkp_key_checksum` (immutable): zero-knowledge proof for reclaim protocol
       (`reclaim_vk`). At the moment we are storing the whole serialized key in the ledger
       state. See `ReclaimZKPKeyChecksum` in `pallet-manta-pay`.

## 3. MantaPay Protocol 

MantaPay protocol defines a decentralized anonymous payment scheme. MantaPay hides asset 
identifers, senders' and receivers' identities, and transaction value. MantaPay supports 
public assets as "base coins": the `mint` function converts a public asset to a private one,
the `relaim` function converts a private asset to a public asset. The supported public
assets here can be any standard assets issued in Polkadot/Kusama or their parachain 
(including Manta). Note, the supported public assets doesn't have to be UTXO based. 

We define the MantaPay protocol as a set of functions running on the client 
(`GenMint`, `GenTransfer`, `GenReclaim`) and a set of functions running on the ledger 
(`Mint`, `Transfer`, `Reclaim`). We call the client Alice and validator Bob. 
Additionally, all these functions takes the same security parameter &lambda; by default.

### 3.1 `GenMint`: generate a mint transaction (client)
`GenMint`(`LS`, &delta;, `Alice`<sub>sk</sub>, `v`) &rarr; 
  (`tx`<sub>mint</sub>, `sig`(`Alice`, `tx`<sub>mint</sub>), `pCoin`). 
  `GenMint` takes the current ledger state `LS`, the mint asset id &delta;, 
  Alice's secret key of her account `Alice`<sub>sk</sub>, and the amount to be minted 
  `v`. The client (a.k.a. Alice) 
  does the following:
  - Alice generates an key pair (`a`<sub>sk</sub>, `a`<sub>pk</sub>) for the priviate
      coin to be minted. More specifically, Alice samples a secret  
      `a`<sub>sk</sub> from the domain 1<sup>&lambda;</sup>, and generates the public 
      key `a`<sub>pk</sub>:=`PRF`<sub>`a`<sub>sk</sub></sub><sup>addr</sup>(0). 
      Note this key pair belongs to the private coin (UTXO) to be generated and can only be used for once.
  - Alice samples a random number &rho; from the domain 1<sup>&lambda;</sup>, which 
      is a secret string that determines the coins void number
      `vn`:=`PRF`<sub>`a`<sub>sk</sub></sub><sup>vn</sup>(&rho;). Note that neither 
      &rho; nor `vn` is included in the mint transaction.
  - Alice commits to the triple (`a`<sub>pk</sub>, `v`, &rho;) in two phases:
        1. sample a random `r`, and compute 
        `k`:=`COMM`<sub>`r`</sub>(`a`<sub>pk</sub> || &rho;).
        2. sample a random `s`, and compute 
        `utxo`:=`COMM`<sub>`s`</sub>( &delta; || `v` || `k`).
  
  As a result, Alice generates and signs a mint transaction (using `Alice`<sub>sk</sub>)
  `tx`<sub>mint</sub>:=(&delta;, `v`, `k`, `utxo`) as well as obtains the information 
  to spent a private coin `pCoin`:=(a<sub>pk</sub>, `v`, &rho;, `r`, `s`, `utxo`).
  
  (TODO: improve the protocol by simplify the commitment here: 
  `a`<sub>pk</sub> doesn't seems necessary)

### 3.2 `Mint`: verify a mint transaction on-chain
`Mint`(`LS`, `tx`<sub>mint</sub>, `sig`(`Alice`, `tx`<sub>mint</sub>)) &rarr; 
  (`LS'`, {0, 1}). Upon receiving `tx`<sub>mint</sub>  and 
  `sig`(`Alice`, `tx`<sub>mint</sub>, Bob does the following:

  - checks the validity of the signature;
  - checks Alice has more than `v` asset &delta;;
  - deducts `v` of asset &delta; from Alice's account to the pool;
  - checks the validity of the utxo: 
    `utxo`=`COMM`<sub>`s`</sub>( &rho; || `v` || `k`);
  - applies the sharding function `sh` to `utxo` to compute its shard index: `i`:=`sh`(`utxo`) and adds `utxo` to the accumulator shard `acc`<sub>i</sub>. (TODO: this need to be implemented in 
  `pallet-manta-pay`)

### 3.3 `GenTransfer`: generate a transfer transaction (client)
`GenTransfer`(LS, &delta;, `c`<sub>1</sub><sup>old</sup>, 
  `c`<sub>2</sub><sup>old</sup>, v<sub>3</sub>, v<sub>4</sub>, `SAddr`<sub>3</sub>, `SAddr`<sub>4</sub>) &rarr;
  (`tx`<sub>transfer</sub>, `c`<sub>3</sub>, `c`<sub>4</sub>). 
  
Suppose Alice want to send `x` asset &delta; to Bob. 
Alice generates a transfer transaction which spends two UTXOs (whose values are `v`<sub>1</sub>and `v`<sub>2</sub>) and transfers their values to two new UTXOs (whose values are `v`<sub>3</sub> and `v`<sub>4</sub>, and `v`<sub>1</sub> + `v`<sub>2</sub> = `v`<sub>3</sub> + `v`<sub>4</sub>). In the generated two new UTXOs, one is with value `x` = `v`<sub>3</sub> and is sent to 
the shielded address of Bob (`SAddr`<sub>4</sub>), the other is the change that Alice
keeps for herself (send to `SAddr`<sub>3</sub>). 
To generate this transfer transactions, `GenTransfer` takes the current ledger state `LS`, the asset id &delta;, and the information
(including secrets) of the two old coins: 
  1. `c`<sub>1</sub><sup>old</sup> = (
    `a`<sub>pk</sub><sup>old</sup>, 
    `v`<sub>1</sub><sup>old</sup>, &rho;<sub>1</sub><sup>old</sup>,
    `r`<sub>1</sub><sup>old</sup>, 
    `s`<sub>1</sub><sup>old</sup>, `utxo`<sub>1</sub><sup>old</sup>
     ).
     This is roughly equivalent to `MantaAsset` struct defined in `manta-types/manta-assets`.
  2. `c`<sub>2</sub><sup>old</sup> = (
     `b`<sub>pk</sub><sup>old</sup>, 
     `v`<sub>2</sub><sup>old</sup>, &rho;<sub>2</sub><sup>old</sup>,
     `r`<sub>2</sub><sup>old</sup>,
     `s`<sub>2</sub><sup>old</sup>, `utxo`<sub>2</sub><sup>old</sup>
     ).
  
  `GenTransfer` also takes two shielded addresses 
  (`SAddr`<sub>3</sub>, `SAddr`<sub>4</sub>). Deserialzied shielded address is 
  roughly equivalent to `MantaAssetShieldedAddress` defined in 
  `manta-types/manta-asset`. Taken `SAddr`<sub>3</sub> as an example, it contains the 
  following:
  - &delta;<sub>3</sub>: an `u32` asset id
  - `r`<sub>3</sub>: a randomly sampled (or derived trapdoor) of 32 bytes
  - `s`<sub>3</sub>: a randomly sampled (or derived trapdoor) of 32 bytes
  - `k`<sub>3</sub>: `k`<sub>3</sub> :=
      `COMM`<sub>`r`<sub>3</sub></sub>(d<sub>pk</sub> || &rho;<sub>3</sub>), 
      where &rho;<sub>3</sub>< is the random seed to derive the void number.
  - `ecpk`<sub>3</sub>: an ECIES public key of the receiver.

  `GenTransfer` generates a tx<sub>transfer</sub> transaction containing the following: 
  - `acc`: the accumulator that represents the ledger state
  - `vn`<sub>1</sub>: `c`<sub>1</sub><sup>old</sup>'s void number, 
  `vn`<sub>1</sub> := `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(&rho;<sub>1</sub><sup>old</sup>) 
  - `vn`<sub>2</sub>: `c`<sub>2</sub><sup>old</sup>'s void number,
  `vn`<sub>2</sub> := `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(&rho;<sub>2</sub><sup>old</sup>)
  - `utxo`<sub>3</sub>: The final commitment of the new coin sent to `SAddr`<sub>3</sub>. `utxo`<sub>3</sub> := `COMM`<sub>`s`<sub>3</sub></sub>( &delta;<sub>3</sub> || `v`<sub>3</sub> || `k`<sub>3</sub>).
  - `utxo`<sub>4</sub>: The final commitment of the new coin sent to `SAddr`<sub>4</sub>. `utxo`<sub>4</sub> := `COMM`<sub>`s`<sub>4</sub></sub>( &delta;<sub>4</sub> || `v`<sub>4</sub> || `k`<sub>4</sub>).
  - `ciphertext`<sub>3</sub>: The ciphertext gerenerated using the plain text (&delta; || `v`<sub>3</sub>) and the encryption key `ecpk`<sub>3</sub> using ECIES.
  - `ciphertext`<sub>4</sub>: The ciphertext gerenerated using the plain text (&delta; || `v`<sub>3</sub>) and the encryption key `ecpk`<sub>3</sub> using ECIES.
  -  &pi;<sub>transfer</sub>: a zero-knowlege proof for the validity of the transfer.  

Additionally, `GenTransfer` also generates two new coins:
- `c`<sub>3</sub> = (`c`<sub>pk</sub>, `v`<sub>3</sub>, &rho;<sub>3</sub>, `r`<sub>3</sub>, `s`<sub>3</sub>, `utxo`<sub>3</sub>)
- `c`<sub>4</sub> = (`d`<sub>pk</sub>, `v`<sub>4</sub>, &rho;<sub>4</sub>, `r`<sub>4</sub>, `s`<sub>4</sub>, `utxo`<sub>4</sub>)

#### NP-Statement of &pi;<sub>transfer</sub>


> Given an accumulator `acc` that represents the ledger state, the void numbers of the first input coin `vn`<sub>1</sub><sup>old</sup> 
and the second input coin `vn`<sub>2</sub><sup>old</sup>, and the 
two new coins' commitment `utxo`<sub>3</sub> and `utxo`<sub>4</sub> (these are all public), "I" knows the following private informations:
>  - `c`<sub>1</sub><sup>old</sup>: the first input coin
>  - `c`<sub>2</sub><sup>old</sup>: the second input coin
>  - `c`<sub>3</sub>: the first transferred coin
>  - `c`<sub>4</sub>: the second the transferred coin
>  - `a`<sub>sk</sub><sup>old</sup>: the secret key of `c`<sub>1</sub><sup>old</sup>
>  - `b`<sub>sk</sub><sup>old</sup>: the secret key of `c`<sub>2</sub><sup>old</sup>
>
> such that the following statements hold:
>
> 1. The addresses and the void numbers are derived from the corresponding secret keys:
    - `a`<sub>pk</sub><sup>old</sup>  = `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`addr`</sup>(0)
    - `b`<sub>pk</sub><sup>old</sup>  = `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`addr`</sup>(0)
    - `vn`<sub>1</sub><sup>old</sup> = `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(0)
    - `vn`<sub>2</sub><sup>old</sup> = `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(0)
> 2. The input coins' commiments are well-formed:
    - `k`<sub>1</sub><sup>old</sup> :=
      `COMM`<sub>`r`<sub>1</sub><sup>old</sup></sub>(`a`<sub>pk</sub><sup>old</sup> || &rho;<sub>1</sub><sup>old</sup>)
    - `k`<sub>2</sub><sup>old</sup> :=
      `COMM`<sub>`r`<sub>2</sub><sup>old</sup></sub>(`b`<sub>pk</sub><sup>old</sup> || &rho;<sub>2</sub><sup>old</sup>)
    - `utxo`<sub>1</sub><sup>old</sup> = 
    `COMM`<sub>`s`<sub>1</sub><sup>old</sup></sub>( &delta;<sub>1</sub><sup>old</sup> || `v`<sub>1</sub> || `k`<sub>1</sub><sup>old</sup>)
    - `utxo`<sub>2</sub><sup>old</sup> = 
    `COMM`<sub>`s`<sub>2</sub><sup>old</sup></sub>( &delta;<sub>2</sub><sup>old</sup> || `v`<sub>2</sub> || `k`<sub>2</sub><sup>old</sup>)
> 3. The input coin's commitments (despite not in tx<sub>transfer</sub>) are members of `acc`: `utxo`<sub>1</sub><sup>old</sup> &in; `acc`, `utxo`<sub>2</sub><sup>old</sup> &in; `acc`.
> 4. The new coins' commitments are also well-formed:
    - `utxo`<sub>3</sub> = 
     `COMM`<sub>`s`<sub>3</sub></sub>( &delta;<sub>3</sub> || `v`<sub>3</sub> || `k`<sub>3</sub>)
    - `utxo`<sub>4</sub> = 
     `COMM`<sub>`s`<sub>4</sub></sub>( &delta;<sub>4</sub> || `v`<sub>4</sub> || `k`<sub>4</sub>)
> 5. All the coins in the transaction has the same asset id: 
 &delta;<sub>1</sub><sup>old</sup> = &delta;<sub>2</sub><sup>old</sup> = &delta;<sub>3</sub> = &delta;<sub>4</sub>
> 6. The old and new coins have the same combined value:
  `v`<sub>1</sub> + `v`<sub>2</sub> = `v`<sub>3</sub> + `v`<sub>4</sub>

### 3.6 `Transfer`: verify a transfer transaction on chain

`Transfer`(LS, tx<sub>transfer</sub>) &rarr; (LS',  {&top;, &bot;})

Upon receiving tx<sub>transfer</sub>, the validtors check the validity of the transaction:

 - `vn`<sub>1</sub><sup>old</sup> and `vn`<sub>2</sub><sup>old</sup> has never used in a previous transaction in the ledger (otherwise it is a double spend)
 - the zkSNARK verifier verifies the validity of &pi;<sub>transfer</sub>  

 If the transaction validation succeed, the validtors appends `vn`<sub>1</sub><sup>old</sup> and `vn`<sub>2</sub><sup>old</sup>, 
 `uxto`<sub>3</sub>, and `utxo`<sub>4</sub> to the ledger state, and update the accumulator `acc` accordingly.

### 3.5 `GenReclaim`: generate a recliam transaction (Client)

`GenReclaim` works similarly to `GenTransfer`, the different is that one of output coins is public. 

`GenReclaim`(`LS`, &delta;, `c`<sub>1</sub><sup>old</sup>, `c`<sub>2</sub><sup>old</sup>, `a`<sub>sk</sub>, `b`<sub>sk</sub>, `v`<sub>3</sub>, `v`<sub>4</sub>, `SAddr`<sub>3</sub>, `PAddr`<sub>4</sub>) 
&rarr; (tx<sub>reclaim</sub>, `c`<sub>3</sub>)

Suppose Alice wants the reclaim `x` value to public on of asset &delta;. She calls `GenReclaim` on a client. `GenReclaim` takes the current ledger state `LS`, the asset id &delta;, and the following information of Alices two old coins:
1. `c`<sub>1</sub><sup>old</sup> = (
    `a`<sub>pk</sub><sup>old</sup>, 
    `v`<sub>1</sub><sup>old</sup>, &rho;<sub>1</sub><sup>old</sup>,
    `r`<sub>1</sub><sup>old</sup>, 
    `s`<sub>1</sub><sup>old</sup>, `utxo`<sub>1</sub><sup>old</sup>
     ).
  2. `c`<sub>2</sub><sup>old</sup> = (
     `b`<sub>pk</sub><sup>old</sup>, 
     `v`<sub>2</sub><sup>old</sup>, &rho;<sub>2</sub><sup>old</sup>,
     `r`<sub>2</sub><sup>old</sup>,
     `s`<sub>2</sub><sup>old</sup>, `utxo`<sub>2</sub><sup>old</sup>
     ).

`GenReclaim` also takes a shielded address `SAddr`<sub>3</sub> and a 
public address `PAddr`<sub>4</sub> and the value pouring into the shielded address `v`<sub>3</sub> and the value pouring into the public address `v`<sub>4</sub> (`v`<sub>4</sub> = `x`). `GenReclaim` generates a tx<sub>reclaim</sub> containing the following:

 - `acc`: the accumulator that represents the ledger state
  - `vn`<sub>1</sub>: `c`<sub>1</sub><sup>old</sup>'s void number, 
  `vn`<sub>1</sub> := `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(&rho;<sub>1</sub><sup>old</sup>) 
  - `vn`<sub>2</sub>: `c`<sub>2</sub><sup>old</sup>'s void number,
  `vn`<sub>2</sub> := `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(&rho;<sub>2</sub><sup>old</sup>)
  - `utxo`<sub>3</sub>: The final commitment of the new coin sent to `SAddr`<sub>3</sub>. `utxo`<sub>3</sub> := `COMM`<sub>`s`<sub>3</sub></sub>( &delta;<sub>3</sub> || `v`<sub>3</sub> || `k`<sub>3</sub>).
  - `ciphertext`<sub>3</sub>: The ciphertext gerenerated using the plain text (&delta; || `v`<sub>3</sub>) and the encryption key `ecpk`<sub>3</sub> using ECIES
  -  &pi;<sub>reclaim</sub>: a zero-knowlege proof for the validity of the reclaim
  - `PAddr`<sub>4</sub>: the public address to receive the reclaimed asset
  - `v`<sub>4</sub>: the value of reclaimed asset

#### NP Statement of &pi;<sub>reclaim</sub>

> Given an accumulator `acc` that represents the ledger state, void numbers `vn`<sub>1</sub><sup>old</sup> and `vn`<sub>2</sub><sup>old</sup>, coin commitment `utxo`<sub>3</sub>, and asset id &delta; (public information), "I" know coins `c`<sub>1</sub><sup>old</sup>, `c`<sub>2</sub><sup>old</sup>, `c`<sub>3</sub>, secret keys `a`<sub>sk</sub><sup>old</sup>, `b`<sub>sk</sub><sup>old</sup>, such that:
> 1. The addresses and the void numbers are derived from the corresponding secret keys:
    - `a`<sub>pk</sub><sup>old</sup>  = `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`addr`</sup>(0)
    - `b`<sub>pk</sub><sup>old</sup>  = `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`addr`</sup>(0)
    - `vn`<sub>1</sub><sup>old</sup> = `PRF`<sub>`a`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(0)
    - `vn`<sub>2</sub><sup>old</sup> = `PRF`<sub>`b`<sub>sk</sub><sup>old</sup></sub><sup>`vn`</sup>(0)
>  2. The input coins' commiments are well-formed:
    - `k`<sub>1</sub><sup>old</sup> :=
      `COMM`<sub>`r`<sub>1</sub><sup>old</sup></sub>(`a`<sub>pk</sub><sup>old</sup> || &rho;<sub>1</sub><sup>old</sup>)
    - `k`<sub>2</sub><sup>old</sup> :=
      `COMM`<sub>`r`<sub>2</sub><sup>old</sup></sub>(`b`<sub>pk</sub><sup>old</sup> || &rho;<sub>2</sub><sup>old</sup>)
    - `utxo`<sub>1</sub><sup>old</sup> = 
    `COMM`<sub>`s`<sub>1</sub><sup>old</sup></sub>( &delta;<sub>1</sub><sup>old</sup> || `v`<sub>1</sub> || `k`<sub>1</sub><sup>old</sup>)
    - `utxo`<sub>2</sub><sup>old</sup> = 
    `COMM`<sub>`s`<sub>2</sub><sup>old</sup></sub>( &delta;<sub>2</sub><sup>old</sup> || `v`<sub>2</sub> || `k`<sub>2</sub><sup>old</sup>)
> 3. The input coin's commitments (despite not in tx<sub>transfer</sub>) are members of `acc`: `utxo`<sub>1</sub><sup>old</sup> &in; `acc`, `utxo`<sub>2</sub><sup>old</sup> &in; `acc`.
> 4. The new coins' commitments are also well-formed:
    - `utxo`<sub>3</sub> = 
     `COMM`<sub>`s`<sub>3</sub></sub>( &delta;<sub>3</sub> || `v`<sub>3</sub> || `k`<sub>3</sub>)
> 5. All the coins in the transaction has the same asset id: 
 &delta;<sub>1</sub><sup>old</sup> = &delta;<sub>2</sub><sup>old</sup> = &delta;<sub>3</sub>
> 6. The old and new coins have the same combined value:
  `v`<sub>1</sub> + `v`<sub>2</sub> = `v`<sub>3</sub> + `v`<sub>4</sub>

### 3.6 `Reclaim`: verify a reclaim transaction on chain

`Reclaim`(`LS`, tx<sub>reclaim</sub>) &rarr; (`LS`', {&top;, &bot;} )

Upon receiving tx<sub>reclaim</sub>, the validators check the validity of the transaction:
- `vn`<sub>1</sub><sup>old</sup> and `vn`<sub>2</sub><sup>old</sup> has never used in a previous transaction in the ledger (otherwise it is a double spend)
 - the zkSNARK verifier verifies the validity of &pi;<sub>reclaim</sub>  

If the transaction validation succeed, the validtors appends `vn`<sub>1</sub><sup>old</sup> and `vn`<sub>2</sub><sup>old</sup>, 
 `uxto`<sub>3</sub>to the ledger state, update the accumulator `acc`, and send `v`<sub>4</sub> amount of asset &delta; to `PAddr`<sub>4</sub>.

## Potential Issues

1. The index of the shard is determined by the first byte of the cm. 
   this may be potentially risky, since the commitment is a group element, 
   and the first byte may not be uniformly distributed between 0 and 255. 
   (TODO:)
