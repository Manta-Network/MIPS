# MIP-0002 : MantaPay Protocol

```
Number:  MIP-0002
Title:   MantaPay Protocol
Type:    Standard
Status:  Draft
Authors: Shumo Chu (shumo@manta.network)
Created: 2021-06-18
```

## Abstract

`MIP-0001` describes the MantaPay protocol. This is inteneded to be an "informal" 
treatment of the protocol that optimizes readablilty. The formal treatment of the 
protocol can be found in this [eprint](https://eprint.iacr.org/2021/743).

## Primitives

* **zkSNARK**: public-verifiable preprocessing zero-knowledge Succinct Non-interactive
  ARgument of Knowledge. zkSNARK is a proof system that verifies computation expressed 
  in a circuit. Given a field F, a zkSANRK for F-arithmetic circuit satisfablility is defined 
  by a triple of polynomial algorithms (`KeyGen`, `Prove`, `Verify`):
    1. `KeyGen`(1<sup>&lambda;</sup>, `C`) &rarr; (`pk`, `vk`). Taken a security parameter 
    &lambda; (e.g. 128 bits) and a F-arithmeic circuit `C`, `KeyGen` samples a pair of keys, 
    namely a proving key `pk` and a verification key `vk`. (`pk`, `vk`) is usually referred 
    as the public parameter or common reference string (CRS).
    2. `Prove`(`pk`, `x`, `a`) &rarr; &pi;. Taken a proving key `pk`, public input `x`, and 
    witness `a` as input, the proving function `Prove` (called by the prover) outputs a
    non-interactive zero-knowledge proof of the designated statement defined by `C`.
    3. `Verify`(`vk`, `x`, &pi;) &rarr; {0, 1}. Taken a verification key `vk`, and a 
    zero-knowledge proof &pi;, `Verify` (called by the verifier) outputs 1 if the prover is convinced that `C` is true, outputs 0 otherwise.
  A zkSNARK satisfies the following properties:
    - **Completeness**. An honest prover must convince the verifier with high probability 
      1 - `negl`(&lambda;).
    - **Soundness**. If the verifier accepts a proof from a prover with bounded computational
      power, then the prover must know the secrets input corresponding to the witness of the 
      given instance.
    - **Succinctness**. An honest-generated proof &pi; has constant size and the `Verify`
      runs in time linear to `x`.
    - **Zero-Knowledge**. An honestly-generated proof is perfect zero knowledge 
      (the formal definition is based on the notion of the simulator, please refer to 
      A.1 section of the eprint).
* **Commitment** (`COMM`). A non-interactive commitment scheme `COMM` that is both hiding 
  and binding (either computational or information theoretical). For example, given a random 
  seed `r`and a message `m`, the commitment is `c` := `COMM`<sub>r</sub>(`m`). `c` can be 
  opened by revealing `r` and `m`, which verifies the commitment.
* **Pseudo-Random Function** (`PRF`). More specifically, we use three labeled pseudo-random
  functions that instantiated from the same core function. For a seed `x`, we derive 
  `PRF`<sub>`x`</sub><sup>`addr`</sup>(&middot;), 
  `PRF`<sub>`x`</sub><sup>`vn`</sup>(&middot;), and
  `PRF`<sub>`x`</sub><sup>`pk`</sup>(&middot;), which is used to generate addresses, 
  void numbers, and public keys, accordingly. Currently, manta uses `Blake2s` as the core 
  function.
* **Cryptographic Accumulator** (`acc`). `acc` supports efficient, zero-knowledge, 
  membership proofs. Currently, Manta uses merkle tree with pedersen hashes as the `CRH` 
  (collision resistence hash). In MantaPay, we use a sharded accumulator with `256` shard,
  each shard can be indexed by a number from `0` to `255`, e.g. `acc`<sub>i</sub>, 
  where 0 &le; i &le; 255.
* **Elliptic Curve Integrated Encryption Scheme** (`ECIES`). `ECIES` is build on top of 
  (elliptic curve) Diffie-Hellman key exchange protocol, a key derivation function and a 
  block cipher. `ECIES` is used to encrypt the nomination of the UTXO using the receiver's 
  public key. (TODO (ask zz): add the instantiation of `ECIES` that Manta uses).

## Shielded Address, UTXO and Ledger State

* **Shielded Address**. A shielded address is the address that the receiver need to 
  send to the sender prior a private transaction. A deserialized shielded address contains 
  the following (see `MantaAssetShieldedAddress` in `manta-types/manta-asset`):
    - `asset_id`: an `u64` (TODO: to be revised) asset id
    - `k`: public information `k` (will be explained later) 
    - `s`: public information `s` (will be explained later)
    - `r`: public information `r` (will be expalined later)
    - `ecpk`: an ECIES public key of the receiver 
  The shielded address will be serialized into a `XXX` bytes address that can be encoded into 
  `XXX` base64 string. (TODO: specify a concrete protocol of serialization).
* **UTXO**. MantaPay uses UTXOs rather than account for the private coins. Both *Mint* and  
  *PrivateTranfer* generates a new UTXO to the ledger state. 
* **Ledger State**. MantaPay's ledger state contains the following:
    - `acc`: A sharded accumulator with `256` shard, i.e. `acc`<sub>i</sub>,  
      where 0 &le; i &le; 255. See `CoinShards` in `pallet-manta-pay`.
    - `vn_list`: a list of void numbers. A void number is also known as a `serial number` 
      or `nullifier` in other protocols. Each coin has a unique void number, and if this
      number is revealed, the coin is voided. See `VNList` in `pallet-manta-pay`.
    - `env_value_list`: a list of encrypted values (of the UTXOs). See `EncValueList` in 
      `pallet-manta-pay`.
    - `pool_balance`: the total balance of MantaPay's private asset pool. See `PoolBalance`
      in `pallet-manta-pay`.
    - `hash_param_checksum` (immutable): the checksum of the `CRH`'s parameters (used in    
      `acc`). See `HashParamChecksum` in `pallet-manta-pay`.
    - `commit_param_checksum` (immutable): the checksum of the commitment's parameters. See
      `CommitParamChecksum` in `pallet-manta-pay`.
    - `transfer_zkp_key_checksum` (immutable): the checksum of the verification key for 
       zero-knowledge proof for transfer protocol (`transfer_vk`). At the moment we are storing the whole serialized key in the ledger state. See `TransferZKPKeyChecksum` 
       in `pallet-manta-pay`.
    - `reclaim_zkp_key_checksum` (immutable): zero-knowledge proof for reclaim protocol
       (`reclaim_vk`). At the moment we are storing the whole serialized key in the ledger
       state. See `ReclaimZKPKeyChecksum` in `pallet-manta-pay`.

## MantaPay Protocol 

MantaPay protocol defines a decentralized anonymous payment scheme. MantaPay hides asset 
identifers, senders' and receivers' identities, and transaction value. MantaPay supports 
public assets as "base coins": the `mint` function converts a public asset to a private one,
the `relaim` function converts a private asset to a public asset. The supported public
assets here can be any standard assets issued in Polkadot/Kusama or their parachain 
(including Manta). Note, the supported public assets doesn't have to be UTXO based. 

We define the MantaPay protocol as a set of functions running on the client 
(`GenMint`, `GenTransfer`, `GenReclaim`) and a set of functions running on the ledger 
(`Mint`, `Transfer`, `Reclaim`). We call the client Alice and validator Bob. 
Additionally, all these functions takes the same security parameter &lambda; by default.

* `GenMint`(`LS`, &delta;, `Alice`<sub>sk</sub>, `v`) &rarr; 
  (`tx`<sub>mint</sub>, `sig`(`Alice`, `tx`<sub>mint</sub>), `pCoin`). 
  `GenMint` takes the current ledger state `LS`, the mint asset id &delta;, 
  Alice's secret key of her account `Alice`<sub>sk</sub>, and the amount to be minted 
  `v`. The client (a.k.a. Alice) 
  does the following:
    - Alice generates an key pair (`a`<sub>sk</sub>, `a`<sub>pk</sub>) for the priviate
      coin to be minted. More specifically, Alice samples a secret  
      `a`<sub>sk</sub> from the domain 1<sup>&lambda;</sup>, and generates the public 
      key `a`<sub>pk</sub>:=`PRF`<sub>`a`<sub>sk</sub></sub><sup>addr</sup>(0). 
      Note this key pair belongs to the private coin (UTXO) to be generated and can only be used for once.
    - Alice samples a random number &rho; from the domain 1<sup>&lambda;</sup>, which 
      is a secret string that determines the coins void number
      `vn`:=`PRF`<sub>`a`<sub>sk</sub></sub><sup>vn</sup>(&rho;). Note that neither 
      &rho; nor `vn` is included in the mint transaction.
    - Alice commits to the triple (`a`<sub>pk</sub>, `v`, &rho;) in two phases:
        1. sample a random `r`, and compute 
        `k`:=`COMM`<sub>`r`</sub>(`a`<sub>pk</sub> || &rho;).
        2. sample a random `s`, and compute 
        `utxo`:=`COMM`<sub>`s`</sub>( &rho; || `v` || `k`).
  
  As a result, Alice generates and signs a mint transaction (using `Alice`<sub>sk</sub>)
  `tx`<sub>mint</sub>:=(&delta;, `v`, `k`, `utxo`) as well as obtains the information 
  to spent a private coin `pCoin`:=(a<sub>pk</sub>, `v`, &rho;, `r`, `s`, `utxo`).
  
  (TODO: improve the protocol by simplify the commitment here: 
  `a`<sub>pk</sub> doesn't seems necessary)
* `Mint`(`LS`, `tx`<sub>mint</sub>, `sig`(`Alice`, `tx`<sub>mint</sub>)) &rarr; 
  (`LS'`, {0, 1}). Upon receiving `tx`<sub>mint</sub>  and 
  `sig`(`Alice`, `tx`<sub>mint</sub>, Bob does the following:
    - checks the validity of the signature;
    - checks Alice has more than `v` asset &delta;;
    - deducts `v` of asset &delta; from Alice's account to the pool;
    - checks the validity of the utxo: 
    `utxo`=`COMM`<sub>`s`</sub>( &rho; || `v` || `k`);
    - applies the sharding function `sh` to `utxo` to compute its shard index: 
    `i`:=`sh`(`utxo`) and adds `utxo` to the accumulator shard `acc`<sub>i</sub>. (TODO: this need to be implemented in 
    `pallet-manta-pay`)

* `GenTransfer`(LS, &delta;, `c`<sub>1</sub><sup>old</sup>, 
  `c`<sub>2</sub><sup>old</sup>, `SAddr`<sub>3</sub>, `SAddr`<sub>4</sub>) &rarr;
  (`tx`<sub>transfer</sub>, `utxo`<sub>3</sub><sup>new</sup>,
  `utxo`<sub>4</sub><sup>new</sup>). 
  Suppose Alice want to send `x` asset &delta; to Bob. 
  Alice generates a transfer transaction which spends two UTXOs (whose sum of
  nomination `v`<sub>1</sub> + `v`<sub>1</sub> &geq; `x`) and transfer their values to 
  two new UTXOs. In the generated two new UTXOs, one is with value `x` and is sent to 
  the shielded address of Bob (`SAddr`<sub>4</sub>), the other is the change that Alice
  keeps for herself (send to `SAddr`<sub>3</sub>). 
  To generate this transfer transactions, `GenTransfer` takes the inforamtions 
  (including secrets) of the two old UTXOs: 
  1. `c`<sub>1</sub><sup>old</sup> = (
    `a`<sub>sk</sub><sup>old</sup>, `a`<sub>pk</sub><sup>old</sup>, 
    `v`<sub>1</sub><sup>old</sup>, &rho;<sub>1</sub><sup>old</sup>,
    `r`<sub>1</sub><sup>old</sup>, `k`<sub>1</sub><sup>old</sup>
    `s`<sub>1</sub><sup>old</sup>, `utxo`<sub>1</sub><sup>old</sup>
     ).
     This is roughly equivalent to `MantaAsset` struct defined in `manta-types/manta-assets`.
  2. `c`<sub>2</sub><sup>old</sup> = (
     `b`<sub>sk</sub><sup>old</sup>, `b`<sub>pk</sub><sup>old</sup>, 
     `v`<sub>2</sub><sup>old</sup>, &rho;<sub>2</sub><sup>old</sup>,
     `r`<sub>2</sub><sup>old</sup>, `k`<sub>2</sub><sup>old</sup>
     `s`<sub>2</sub><sup>old</sup>, `utxo`<sub>2</sub><sup>old</sup>
     ).
  `GenTransfer` also takes two shielded addresses 
  (`SAddr`<sub>3</sub>, `SAddr`<sub>4</sub>). Deserialzied shielded address is 
  roughly equivalent to `MantaAssetShieldedAddress` defined in 
  `manta-types/manta-asset`. Taken `SAddr`<sub>3</sub> as an example, it contains the 
  following:
   - `r`<sub>3</sub>: a randomly sampled (or derived) trapdoor.
   - `s`<sub>3</sub>: a randomly sampled (or derived) trapdoor.
   - `k`<sub>3</sub>: `k`<sub>3</sub> :=
      `COMM`<sub>`r`<sub>3</sub></sub>(d<sub>pk</sub> || &rho;<sub>3</sub>), 
      where &rho;<sub>3</sub>< is the random seed to derive the void number.
  - `utxo`<sub>3</sub>: `utxo`<sub>3</sub> := 
    `COMM`<sub>`s`<sub>3</sub></sub>(&delta;<sub>3</sub> || 
     `v`<sub>3</sub> || `k`<sub>3</sub>), 

## Potential Issues

1. The index of the shard is determined by the first byte of the cm. 
   this may be potentially risky, since the commitment is a group element, 
   and the first byte may not be uniformly distributed between 0 and 255. 
   (TODO:)
